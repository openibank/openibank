//! OpeniBank Wallet - Policy-enforcing signing and custody substrate
//!
//! The wallet is NOT a UI, NOT a simple balance.
//! It is a policy-controlled signing + custody + policy engine.
//!
//! The wallet:
//! - Holds keys / custody adapters
//! - Enforces budget envelopes
//! - Issues SpendPermits
//! - Invokes settlement rails
//! - Emits receipts
//!
//! The wallet NEVER decides intent - policy + commitment gate do.

use std::collections::HashMap;

use chrono::{Duration, Utc};
use serde::{Deserialize, Serialize};

use crate::commitment::{CommitmentGate, CommitmentReceipt, ConsequenceRef, EvidenceBundle};
use crate::crypto::Keypair;
use crate::error::{CoreError, Result};
use crate::types::*;

// ============================================================================
// Wallet Compartments
// ============================================================================

/// Types of wallet compartments
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum CompartmentType {
    /// Long-term holdings, rarely touched
    Vault,
    /// Rate-limited, spend-capped operational budget
    OperationalBudget,
    /// Condition-locked escrow
    Escrow,
    /// Delegated to a sub-agent or tool
    Delegated { delegate_id: ResonatorId },
}

/// A compartment within a wallet
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletCompartment {
    pub compartment_type: CompartmentType,
    pub balances: HashMap<AssetId, Amount>,
    pub budget: Option<BudgetPolicy>,
    pub escrows: HashMap<EscrowId, Escrow>,
}

impl WalletCompartment {
    pub fn new(compartment_type: CompartmentType) -> Self {
        Self {
            compartment_type,
            balances: HashMap::new(),
            budget: None,
            escrows: HashMap::new(),
        }
    }

    pub fn balance(&self, asset: &AssetId) -> Amount {
        self.balances.get(asset).copied().unwrap_or(Amount::zero())
    }

    pub fn credit(&mut self, asset: &AssetId, amount: Amount) -> Result<()> {
        let current = self.balance(asset);
        let new_balance = current.checked_add(amount).ok_or(CoreError::InvalidAmount {
            message: "Balance overflow".to_string(),
        })?;
        self.balances.insert(asset.clone(), new_balance);
        Ok(())
    }

    pub fn debit(&mut self, asset: &AssetId, amount: Amount) -> Result<()> {
        let current = self.balance(asset);
        let new_balance =
            current
                .checked_sub(amount)
                .ok_or(CoreError::InsufficientBalance {
                    available: current.0,
                    required: amount.0,
                })?;
        self.balances.insert(asset.clone(), new_balance);
        Ok(())
    }
}

// ============================================================================
// Wallet
// ============================================================================

/// The OpeniBank Wallet
///
/// A wallet is a policy-enforcing signing and custody substrate for a Resonator.
/// It has mandatory compartments and enforces all spending rules.
#[derive(Clone)]
pub struct Wallet {
    /// The Resonator that owns this wallet
    owner: ResonatorId,
    /// Signing keypair for this wallet
    keypair: Keypair,
    /// Wallet compartments
    compartments: HashMap<CompartmentType, WalletCompartment>,
    /// Active permits issued by this wallet
    permits: HashMap<PermitId, SpendPermit>,
    /// Commitment gate for creating receipts
    commitment_gate: CommitmentGate,
    /// All receipts generated by this wallet
    receipts: Vec<CommitmentReceipt>,
}

impl Wallet {
    /// Create a new wallet for a Resonator
    pub fn new(owner: ResonatorId) -> Self {
        let keypair = Keypair::generate();
        let commitment_gate = CommitmentGate::new(keypair.clone());

        let mut compartments = HashMap::new();

        // Create mandatory compartments
        compartments.insert(CompartmentType::Vault, WalletCompartment::new(CompartmentType::Vault));
        compartments.insert(
            CompartmentType::OperationalBudget,
            WalletCompartment::new(CompartmentType::OperationalBudget),
        );
        compartments.insert(
            CompartmentType::Escrow,
            WalletCompartment::new(CompartmentType::Escrow),
        );

        Self {
            owner,
            keypair,
            compartments,
            permits: HashMap::new(),
            commitment_gate,
            receipts: Vec::new(),
        }
    }

    /// Create a wallet with a specific keypair
    pub fn with_keypair(owner: ResonatorId, keypair: Keypair) -> Self {
        let commitment_gate = CommitmentGate::new(keypair.clone());

        let mut compartments = HashMap::new();
        compartments.insert(CompartmentType::Vault, WalletCompartment::new(CompartmentType::Vault));
        compartments.insert(
            CompartmentType::OperationalBudget,
            WalletCompartment::new(CompartmentType::OperationalBudget),
        );
        compartments.insert(
            CompartmentType::Escrow,
            WalletCompartment::new(CompartmentType::Escrow),
        );

        Self {
            owner,
            keypair,
            compartments,
            permits: HashMap::new(),
            commitment_gate,
            receipts: Vec::new(),
        }
    }

    /// Get the wallet owner
    pub fn owner(&self) -> &ResonatorId {
        &self.owner
    }

    /// Get the wallet's public key
    pub fn public_key(&self) -> String {
        self.keypair.public_key_hex()
    }

    /// Get a compartment by type
    pub fn compartment(&self, compartment_type: &CompartmentType) -> Result<&WalletCompartment> {
        self.compartments.get(compartment_type).ok_or_else(|| {
            CoreError::CompartmentNotFound {
                compartment: format!("{:?}", compartment_type),
            }
        })
    }

    /// Get a mutable compartment by type
    pub fn compartment_mut(
        &mut self,
        compartment_type: &CompartmentType,
    ) -> Result<&mut WalletCompartment> {
        self.compartments.get_mut(compartment_type).ok_or_else(|| {
            CoreError::CompartmentNotFound {
                compartment: format!("{:?}", compartment_type),
            }
        })
    }

    /// Get the operational budget balance for an asset
    pub fn balance(&self, asset: &AssetId) -> Amount {
        self.compartment(&CompartmentType::OperationalBudget)
            .map(|c| c.balance(asset))
            .unwrap_or(Amount::zero())
    }

    /// Credit funds to the operational budget
    pub fn credit(&mut self, asset: &AssetId, amount: Amount) -> Result<()> {
        self.compartment_mut(&CompartmentType::OperationalBudget)?
            .credit(asset, amount)
    }

    /// Set a budget policy for the operational compartment
    pub fn set_budget(&mut self, budget: BudgetPolicy) -> Result<()> {
        let compartment = self.compartment_mut(&CompartmentType::OperationalBudget)?;
        compartment.budget = Some(budget);
        Ok(())
    }

    /// Get the current budget policy
    pub fn budget(&self) -> Option<&BudgetPolicy> {
        self.compartment(&CompartmentType::OperationalBudget)
            .ok()
            .and_then(|c| c.budget.as_ref())
    }

    /// Issue a SpendPermit
    ///
    /// Permits are the agent-native "currency of authority".
    pub fn issue_permit(
        &mut self,
        max_amount: Amount,
        counterparty: CounterpartyConstraint,
        purpose: SpendPurpose,
        duration: Duration,
    ) -> Result<SpendPermit> {
        // Get the budget
        let budget = self.budget().ok_or(CoreError::PolicyViolation {
            message: "No budget policy set".to_string(),
        })?;

        // Check if the budget can support this permit
        // (This is a soft check - actual enforcement happens at commitment time)
        let remaining_budget = budget
            .max_total
            .checked_sub(budget.spent_total)
            .unwrap_or(Amount::zero());

        if max_amount > remaining_budget {
            return Err(CoreError::BudgetExceeded {
                message: format!(
                    "Permit amount {} exceeds remaining budget {}",
                    max_amount, remaining_budget
                ),
            });
        }

        let now = Utc::now();
        let permit_id = PermitId::new();

        // Create the permit
        let permit = SpendPermit {
            permit_id: permit_id.clone(),
            issuer: self.owner.clone(),
            bound_budget: budget.budget_id.clone(),
            asset_class: AssetClass::Stablecoin,
            max_amount,
            remaining: max_amount,
            counterparty,
            purpose,
            issued_at: now,
            expires_at: now + duration,
            signature: String::new(), // Will be signed below
        };

        // Sign the permit
        let permit_bytes = serde_json::to_vec(&permit)?;
        let signature = self.keypair.sign(&permit_bytes);

        let signed_permit = SpendPermit { signature, ..permit };

        // Store the permit
        self.permits.insert(permit_id, signed_permit.clone());

        Ok(signed_permit)
    }

    /// Get a permit by ID
    pub fn get_permit(&self, permit_id: &PermitId) -> Option<&SpendPermit> {
        self.permits.get(permit_id)
    }

    /// Get a mutable permit by ID
    pub fn get_permit_mut(&mut self, permit_id: &PermitId) -> Option<&mut SpendPermit> {
        self.permits.get_mut(permit_id)
    }

    /// Execute a payment through the commitment gate
    ///
    /// This is the main entry point for making payments.
    /// It enforces all invariants and produces a receipt.
    pub fn execute_payment(
        &mut self,
        intent: PaymentIntent,
    ) -> Result<(CommitmentReceipt, EvidenceBundle)> {
        // Get the permit
        let permit = self
            .permits
            .get(&intent.permit)
            .ok_or(CoreError::PolicyViolation {
                message: "Permit not found".to_string(),
            })?
            .clone();

        // Get the budget
        let budget = self.budget().ok_or(CoreError::PolicyViolation {
            message: "No budget policy set".to_string(),
        })?.clone();

        // Check if we have sufficient balance
        let compartment = self.compartment(&CompartmentType::OperationalBudget)?;
        let current_balance = compartment.balance(&intent.asset);
        if current_balance < intent.amount {
            return Err(CoreError::InsufficientBalance {
                available: current_balance.0,
                required: intent.amount.0,
            });
        }

        // Create the consequence reference (will be filled in by ledger)
        let consequence = ConsequenceRef {
            consequence_type: "ledger_transfer".to_string(),
            reference_id: format!("transfer_{}", uuid::Uuid::new_v4()),
            metadata: serde_json::json!({
                "from": self.owner.0,
                "to": intent.target.0,
                "amount": intent.amount.0,
                "asset": intent.asset.0,
            }),
        };

        // Create the commitment (this validates everything)
        let (receipt, evidence) =
            self.commitment_gate
                .create_commitment(&intent, &permit, &budget, consequence)?;

        // Debit from our balance
        self.compartment_mut(&CompartmentType::OperationalBudget)?
            .debit(&intent.asset, intent.amount)?;

        // Consume from the permit
        if let Some(p) = self.permits.get_mut(&intent.permit) {
            p.consume(intent.amount)?;
        }

        // Update budget spent total
        if let Some(ref mut b) = self
            .compartment_mut(&CompartmentType::OperationalBudget)?
            .budget
        {
            b.record_spend(intent.amount)?;
        }

        // Store the receipt
        self.receipts.push(receipt.clone());

        Ok((receipt, evidence))
    }

    /// Create an escrow
    pub fn create_escrow(&mut self, intent: EscrowIntent) -> Result<Escrow> {
        // Debit from operational budget
        self.compartment_mut(&CompartmentType::OperationalBudget)?
            .debit(&intent.asset, intent.locked_amount)?;

        // Create the escrow
        let escrow = Escrow {
            escrow_id: intent.escrow_id.clone(),
            invoice_id: intent.invoice.clone(),
            payer: intent.payer.clone(),
            payee: intent.payee.clone(),
            amount: intent.locked_amount,
            asset: intent.asset.clone(),
            state: EscrowState::Locked,
            release_conditions: intent.release_conditions.clone(),
            arbiter: intent.arbiter.clone(),
            created_at: intent.created_at,
            expires_at: intent.expires_at,
        };

        // Store in escrow compartment
        self.compartment_mut(&CompartmentType::Escrow)?
            .escrows
            .insert(escrow.escrow_id.clone(), escrow.clone());

        // Credit to escrow compartment balance
        self.compartment_mut(&CompartmentType::Escrow)?
            .credit(&intent.asset, intent.locked_amount)?;

        Ok(escrow)
    }

    /// Release an escrow to the payee
    pub fn release_escrow(&mut self, escrow_id: &EscrowId) -> Result<Amount> {
        // Get and remove the escrow
        let escrow = self
            .compartment_mut(&CompartmentType::Escrow)?
            .escrows
            .remove(escrow_id)
            .ok_or_else(|| CoreError::EscrowNotFound {
                escrow_id: escrow_id.0.clone(),
            })?;

        // Check state
        if escrow.state != EscrowState::Locked {
            return Err(CoreError::EscrowConditionsNotMet {
                reason: format!("Escrow is in state {:?}, not Locked", escrow.state),
            });
        }

        // Debit from escrow compartment
        self.compartment_mut(&CompartmentType::Escrow)?
            .debit(&escrow.asset, escrow.amount)?;

        Ok(escrow.amount)
    }

    /// Get all receipts
    pub fn receipts(&self) -> &[CommitmentReceipt] {
        &self.receipts
    }

    /// Get an escrow by ID
    pub fn get_escrow(&self, escrow_id: &EscrowId) -> Option<&Escrow> {
        self.compartment(&CompartmentType::Escrow)
            .ok()
            .and_then(|c| c.escrows.get(escrow_id))
    }

    /// Update escrow conditions
    pub fn update_escrow_conditions(
        &mut self,
        escrow_id: &EscrowId,
        condition_index: usize,
        met: bool,
    ) -> Result<()> {
        let escrow = self
            .compartment_mut(&CompartmentType::Escrow)?
            .escrows
            .get_mut(escrow_id)
            .ok_or_else(|| CoreError::EscrowNotFound {
                escrow_id: escrow_id.0.clone(),
            })?;

        if condition_index >= escrow.release_conditions.len() {
            return Err(CoreError::EscrowConditionsNotMet {
                reason: "Condition index out of bounds".to_string(),
            });
        }

        escrow.release_conditions[condition_index].met = met;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_creation() {
        let owner = ResonatorId::new();
        let wallet = Wallet::new(owner.clone());

        assert_eq!(wallet.owner(), &owner);
        assert!(!wallet.public_key().is_empty());
    }

    #[test]
    fn test_wallet_balance_operations() {
        let owner = ResonatorId::new();
        let mut wallet = Wallet::new(owner);

        let asset = AssetId::iusd();

        // Initial balance should be zero
        assert_eq!(wallet.balance(&asset), Amount::zero());

        // Credit some funds
        wallet.credit(&asset, Amount::new(1000)).unwrap();
        assert_eq!(wallet.balance(&asset), Amount::new(1000));
    }

    #[test]
    fn test_permit_issuance() {
        let owner = ResonatorId::new();
        let mut wallet = Wallet::new(owner.clone());

        // Set up budget
        let budget = BudgetPolicy::new(owner, Amount::new(10000));
        wallet.set_budget(budget).unwrap();

        // Issue a permit
        let permit = wallet
            .issue_permit(
                Amount::new(500),
                CounterpartyConstraint::Any,
                SpendPurpose {
                    category: "test".to_string(),
                    description: "Test permit".to_string(),
                },
                Duration::hours(1),
            )
            .unwrap();

        assert!(permit.is_valid());
        assert_eq!(permit.remaining, Amount::new(500));
    }

    #[test]
    fn test_permit_exceeds_budget() {
        let owner = ResonatorId::new();
        let mut wallet = Wallet::new(owner.clone());

        // Set up small budget
        let budget = BudgetPolicy::new(owner, Amount::new(100));
        wallet.set_budget(budget).unwrap();

        // Try to issue a permit that exceeds budget
        let result = wallet.issue_permit(
            Amount::new(500),
            CounterpartyConstraint::Any,
            SpendPurpose {
                category: "test".to_string(),
                description: "Test permit".to_string(),
            },
            Duration::hours(1),
        );

        assert!(matches!(result, Err(CoreError::BudgetExceeded { .. })));
    }

    #[test]
    fn test_payment_execution() {
        let owner = ResonatorId::new();
        let target = ResonatorId::new();
        let mut wallet = Wallet::new(owner.clone());

        let asset = AssetId::iusd();

        // Set up wallet with funds and budget
        wallet.credit(&asset, Amount::new(1000)).unwrap();
        let budget = BudgetPolicy::new(owner.clone(), Amount::new(10000));
        wallet.set_budget(budget).unwrap();

        // Issue a permit
        let permit = wallet
            .issue_permit(
                Amount::new(500),
                CounterpartyConstraint::Any,
                SpendPurpose {
                    category: "test".to_string(),
                    description: "Test".to_string(),
                },
                Duration::hours(1),
            )
            .unwrap();

        // Create payment intent
        let intent = PaymentIntent::new(
            owner,
            permit.permit_id.clone(),
            target,
            Amount::new(100),
            asset.clone(),
            SpendPurpose {
                category: "test".to_string(),
                description: "Test payment".to_string(),
            },
        );

        // Execute payment
        let (receipt, _evidence) = wallet.execute_payment(intent).unwrap();

        // Verify receipt
        assert!(receipt.verify().is_ok());

        // Check balance was debited
        assert_eq!(wallet.balance(&asset), Amount::new(900));

        // Check permit was consumed
        let updated_permit = wallet.get_permit(&permit.permit_id).unwrap();
        assert_eq!(updated_permit.remaining, Amount::new(400));
    }

    #[test]
    fn test_escrow_lifecycle() {
        let payer = ResonatorId::new();
        let payee = ResonatorId::new();
        let mut wallet = Wallet::new(payer.clone());

        let asset = AssetId::iusd();

        // Set up wallet with funds
        wallet.credit(&asset, Amount::new(1000)).unwrap();

        // Create escrow intent
        let intent = EscrowIntent {
            escrow_id: EscrowId::new(),
            invoice: InvoiceId::new(),
            payer: payer.clone(),
            payee: payee.clone(),
            locked_amount: Amount::new(500),
            asset: asset.clone(),
            release_conditions: vec![ReleaseCondition {
                condition_type: "delivery_proof".to_string(),
                parameters: serde_json::json!({}),
                met: false,
            }],
            arbiter: None,
            created_at: Utc::now(),
            expires_at: Utc::now() + Duration::days(7),
        };

        let escrow_id = intent.escrow_id.clone();

        // Create escrow
        let escrow = wallet.create_escrow(intent).unwrap();
        assert_eq!(escrow.state, EscrowState::Locked);

        // Operational balance should be debited
        assert_eq!(wallet.balance(&asset), Amount::new(500));

        // Mark condition as met
        wallet.update_escrow_conditions(&escrow_id, 0, true).unwrap();

        // Release escrow
        let released_amount = wallet.release_escrow(&escrow_id).unwrap();
        assert_eq!(released_amount, Amount::new(500));
    }
}
